<!DOCTYPE html>
<html lang='en'>
  <head>
    <meta charset='utf-8'>
    <title>W3C HTML JSON form submission</title>
    <script src='http://www.w3.org/Tools/respec/respec-w3c-common' async class='remove'></script>
    <script class='remove'>
      var respecConfig = {
              specStatus:   "unofficial"
          ,   shortName:    "html-json-forms"
          ,   editors:      [{ name: "Robin Berjon", url: "http://berjon.com/",
                               company: "W3C", companyURL: "http://w3.org/" }]
          ,   wg:           "HTML Working Group"
          ,   wgURI:        "http://www.w3.org/html/wg/"
          ,   wgPublicList: "public-html"
          ,   wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/40318/status"
          ,   edDraftURI:   "http://darobin.github.com/formic/specs/json.html"
          ,   license:      "cc-by"
          ,   bugTracker: {
                  open: "https://github.com/darobin/formic/issues?labels=json&page=1&state=open"
              ,   new:  "https://github.com/darobin/formic/issues/new"
              }
          ,   issueBase:    "https://github.com/darobin/formic/issues/"
        };
    </script>
  </head>
  <body>
    <section id='abstract'>
      <p>
        This specification defines a new form encoding algorithm that enables the transmission of
        form data as JSON. Instead of capturing form data as essentially an array of key-value pairs
        which is the bread and butter of existing form encodings, it relies on a simple
        <code>name</code> attribute syntax that makes it possible to capture rich data structures
        as JSON directly.
      </p>
    </section>
    <section id='sotd'>
      <p>
        This specification is an 
        <a href='http://dev.w3.org/html5/decision-policy/html5-2014-plan.html#extension-specs'>extension
        specification</a> to HTML.
      </p>
    </section>
    <section class='informative'>
      <h2>Introduction</h2>
      <p>
        JSON is commonly used as an exchange format between Web client and backend services. 
        Enabling HTML forms to submit JSON directly simplifies implementation as it enables backend
        services to operate by accepting a single input format that is what's more able to encode
        richer structure than other form encodings (where structure has traditional had to be
        emulated).
      </p>
      <p>
        User agents that implement this specification will transmit JSON data from their forms 
        whenever the form's <code>enctype</code> attribute is set to <code>application/json</code>.
        During the transition period, user agents that do not support this encoding will fall back
        to using <code>application/x-www-form-urlencoded</code>. This can be detected on the server
        side, and the conversion algorithm described in this specification can be used to convert
        such data to JSON.
      </p>
      <p>
        The path format used in input <code>name</code>s is straightforward. To begin with, when
        no structuring information is present, the information will simply be captured as keys in
        a JSON object:
      </p>
      <pre class='example highlight' title='Basic keys'>
        &lt;form enctype=&#x27;application/json&#x27;&gt;
          &lt;input name=&#x27;name&#x27; value=&#x27;Bender&#x27;&gt;
          &lt;select name=&#x27;hind&#x27;&gt;
            &lt;option selected&gt;Bitable&lt;/option&gt;
            &lt;option&gt;Kickable&lt;/option&gt;
          &lt;/select&gt;
          &lt;input type=&#x27;checkbox&#x27; name=&#x27;shiny&#x27; checked&gt;
        &lt;/form&gt;

        // produces
        {
          "name":   "Bender"
        , "hind":   "Bitable"
        , "shiny":  true
        }
      </pre>
      <p>
        If a path is repeated, its value is captured as an array:
      </p>
      <pre class='example highlight' title='Multiple values'>
        &lt;form enctype=&#x27;application/json&#x27;&gt;
          &lt;input type=&#x27;number&#x27; name=&#x27;bottle-on-wall&#x27; value=&#x27;1&#x27;&gt;
          &lt;input type=&#x27;number&#x27; name=&#x27;bottle-on-wall&#x27; value=&#x27;2&#x27;&gt;
          &lt;input type=&#x27;number&#x27; name=&#x27;bottle-on-wall&#x27; value=&#x27;3&#x27;&gt;
        &lt;/form&gt;

        // produces
        {
          "bottle-on-wall":   [1, 2, 3]
        }
      </pre>
      <!--
        - explain key format
        - give examples
        - mention files
        - check all examples
      -->
      <section>
        <h2>Issues</h2>
        <p>
          Every part of this specification is naturally open for comments and discussion, but the
          following items are of particular importance.
        </p>
        <p class='issue' data-number='1' title='JSON root types'>
          Currently we only support JSON objects at the root, which seems sufficient. But JSON can
          also support other root types. Are there strong use cases to add support for these
          (knowing that it would likely complicate matters a fair bit).
        </p>
        <p class='issue' data-number='2' title='Path syntax'>
          The path syntax used in name attributes was selected to match that often seen in the wild
          in order to capture structure in forms, the idea being that it is simple and likely to be
          close to what is already supported, thereby enabling easy fallback to existing software
          during the transition and reusing developer habits. But if there are compelling reasons to
          use another syntax we can investigate them.
        </p>
        <p class='issue' data-number='3' title='Base64'>
          Is the representation for files the best, knowing that base64 incurs an overhead?
        </p>
        <p class='issue' data-number='4' title='Is append needed?'>
          We have an "append" construct (<code>foo[]</code>) that is used for cases in which the
          developer wishes to indicate that even if there is only one instance of a given field name
          it should nevertheless be captured as an array. It is possible to achieve the same effect
          by carefully generating array indices, though it is slightly cumbersome. The feature is
          not costly in complexity, but given that it basically desugars to arrays it could be
          dropped with no loss of functionality.
        </p>
        <p class='issue' data-number='5' title='Boolean radio/checkbox'>
          With the current algorithm, radio and checkbox inputs that are checked and have no
          <code>value</code> set are represented in JSON using a boolean <code>true</code> value
          instead of the <code>on</code> string used in other encodings. This seems like a better
          fit for a new encoding, but the departure from tradition may surprise some. (Note that
          unchecked inputs will still be absent, not <code>false</code>.)
        </p>
        <p class='issue' data-number='6' title='Ignore charsets'>
          The other existing encodings respect <code>accept-charset</code> (and other charset
          selecting methods). For JSON we blithely ignore them and just use UTF-8. This is of course
          the better thing to do, but we are open to considering that there could be issues with
          this approach.
        </p>
      </section>
    </section>
    
    <section id='conformance'></section>
    
    <section>
      <h2>Terminology</h2>
      <p>
        The following terms are defined in the HTML specification. [[!HTML5]]
      </p>
      <ul>
        <li>XXX</li>
      </ul>
    </section>
    
    <section>
      <h2>The <dfn><code>application/json</code> encoding algorithm</dfn></h2>
      <p>
        XXX
      </p>
    </section>
    <section>
      <h2>Acknowledgements</h2>
      <p>
        Thanks to Philippe Le HÃ©garet for serving as a sounding board for the first version of the
        encoding algorithm.
      </p>
    </section>
  </body>
</html>
